<body id=b>

<script>

b.innerHTML = `
<h4>Plain text
<p><textarea id=a cols=75>Hi</textarea>
<div id=O>`;

(oninput = function(){
O.innerHTML = `
<h4>Code points
<p><input size=99 id=c>
<h4>HTML entities
<p><input size=99 id=d>
<p><input size=99 id=e>
<h4>JS/ES6 escape
<p><input size=99 id=f>
<p><input size=99 id=g>
<h4>URI
<p><input size=99 id=h>
<h4>UTF-8 hex/base64
<p><input size=99 id=j>
<p><input size=99 id=k>
<h4>UTF-16BE hex/base64
<p><input size=99 id=l>
<p><input size=99 id=m>
<h4>UTF-16LE hex/base64
<p><input size=99 id=n>
<p><input size=99 id=o>
<h4>UTF-32BE hex/base64
<p><input size=99 id=q>
<p><input size=99 id=r>
<h4>UTF-32LE hex/base64
<p><input size=99 id=s>
<p><input size=99 id=u>
<h4>Windows-1252 text/hex/base64
<p><input size=99 id=w>
<p><input size=99 id=x>
<p><input size=99 id=B>
<h4>Windows-1252 -> UTF-8
<p><input size=99 id=C>
<h4>UTF-8 -> Windows-1252
<p><input size=99 id=D>
<style>body{font:1em arial`;


// Save input text in `v`.
v = a.value;

// Separate the glyphs in an array `t`.
t = [...v];

// Loop on all the glyphs using `i`.
for(i of t){
  
  // Remember the current code point `p`. 
  p = i.codePointAt();
  
  // URL-encode the current glyph `z`.
  z = encodeURIComponent(i);
  
  // List the code points ("U+....").
  c.value += "U+" + p.toString(16).padStart(p > 0xFFFF ? -5 : -4,0) + " ";
  
  // HTML entities ("&#...;" / "&#x...;").
  d.value += "&#" + p + ";";
  e.value += "&#x" + p.toString(16) + ";";
  
  // ES6 escape ("\u{....}").
  g.value += "\\u{" + p.toString(16) + "}";
  
  // EncodeURI.
  h.value += z;
  
  // UTF-8 bytes (code point in base 16 for url-safe chars / same as url-encoded without "%" for the other chars).
  j.value += z.length > 1 ? z.replace(/%(..)/g, '$1 ') : p.toString(16).padStart(2,0) + " ";
  
  // UTF-32 BE hex (same as code point but zero-padded).
  q.value += p.toString(16).padStart(8,0) + " ";
  
  // Windows-1252:

    // For all ASCII chars (U+00 to U+7F) and for chars U+A0 to U+FF, Windows-1252 is similar to Unicode:
    if(p < 0x80 || (p > 0x9F && p < 0x100)){
    
      // Add char in "compatible text".
      w.value += i;

      // Add its padded code point in "hex".
      x.value += p.toString(16).padStart(2,0) + " ";
      
      // Add its code point encoded in latin-1 in the base64 field.
      B.value += String.fromCodePoint(p);
    }
    
    // For chars U+80 to U+9F, use `W` containing 32 hardcoded glyphs: "€‚ƒ„…†‡ˆ‰Š‹ŒŽ‘’“”•–—˜™š›œž".
    else {
      
      // Loop on all glyphs of W using `I`:
      for(I in W = "€‚ƒ„…†‡ˆ‰Š‹ŒŽ‘’“”•–—˜™š›œž"){
        
        // If the glyph is present in W:
        if(W[I] == i){
          
          // Add it to "compatible text".
          w.value += i;
          
          // Add its padded code point in "hex".
          x.value += (128+ +I).toString(16).padStart(2,0) + " ";
          
          // Add its code point encoded in latin-1 in the base64 field.
          B.value += String.fromCodePoint(128 + +I);
        }
      }	
    }
}

// Encode the latin-1 string in base64.
B.value = btoa(B.value);

// XHR the Windws-1252 string encoded in base64, with a UTF-8 charset to see how it is interpreted as UTF-8. 
with(new XMLHttpRequest){open("GET","data:;charset=utf-8;base64,"+B.value,!1),send(),C.value=responseText};

// Encode each byte of the UTF-8 string in latin-1 and convert the whole latin-1 string in base64 to see UTF-8 as base64.
k.value = btoa(j.value.replace(/.. /g, a => String.fromCodePoint(parseInt(a,16))));

// Similarly, encode each byte of UTF-32 BE in latin-1 and base64 it to see UTF-32 BE as base64. 
r.value = btoa(q.value.replace(/(..)(..)(..)(..) /g, (a,b,c,d,e)=> {return String.fromCodePoint(parseInt(b,16)) + String.fromCodePoint(parseInt(c,16)) + String.fromCodePoint(parseInt(d,16)) + String.fromCodePoint(parseInt(e,16));}));

// Rearrange the bytes of UTF-32 BE to make UTF-32 LE.
s.value = q.value.replace(/(..)(..)(..)(..) /g, "$4$3$2$1 ");

// UTF-32 LE in base64.
u.value = btoa(s.value.replace(/(..)(..)(..)(..) /g, (a,b,c,d,e)=> {return String.fromCodePoint(parseInt(b,16)) + String.fromCodePoint(parseInt(c,16)) + String.fromCodePoint(parseInt(d,16)) + String.fromCodePoint(parseInt(e,16));}));

// Loop on UTF-16 BE char codes (a for-in loop in JS does that).
for(i in v){

  // Save the current code point `p`.
  p = v[i].codePointAt();
  
  // JS escape ("\u....;").
  f.value += "\\u" + p.toString(16).padStart(4,0);
  
  // UTF-16 BE hex.
  l.value += p.toString(16).padStart(4,0) + " ";
}

// Encode the UTF-16 BE bytes in base64. 
m.value = btoa(l.value.replace(/(..)(..) /g, (a,b,c)=> {return String.fromCodePoint(parseInt(b,16)) + String.fromCodePoint(parseInt(c,16));}));

// Convert UTF-16 BE bytes in UF-16 LE.
n.value = l.value.replace(/(..)(..) /g, "$2$1 ");

// Convert UTF-16 LE bytes to base64
o.value = btoa(n.value.replace(/(..)(..) /g, (a,b,c)=> {return String.fromCodePoint(parseInt(b,16)) + String.fromCodePoint(parseInt(c,16));}));

// XHR the UTF-8 string encoded in base64, with a Windows-1253 charset to see how it is interpreted as Windows-1252. 
with(new XMLHttpRequest){open("GET","data:;charset=windows-1252;base64,"+k.value,!1),send(),D.value=responseText};

})()
</script>